use arcboot::interrupt_handler

// setup interrupt handlers from arcboot
// basically, registers the fn with arcservices.register() at initialisation
@interrupt_handler(Syscall)
handle_syscall: (number: NeutronSyscall) {
    // HOW syscalls work on neutron
    // neutronapi uses the syscall enum'd numbers and sets them in a0

    // INTERNALLY, neutron uses a set of config options (stored in /sys/config) to determine:
    // expiry duration of a key (usually 3 days to 1 week)
    // the permissions a key has
    // etc.
    // Normally, spx:security should intercept all process requests to do certain things and push a notification to spx:quanta-desktop

    // when a process starts/spawns, it has to fetch its key from spx:security or the kernel or its own file (read-only by the kernel or spx:sec only) itself in order to be able to access system resources
    // each time it tries to access a system resource, it has send a request with its key to the spx's address space circular buffer through the UBus
    // which is locked behind a mutex. NOTE: if the buffer would be full, the process simply busy waits until it isnt, or can yield to the scheduler and be rescheduled later (usually at a higher priority each time it has to be rescheduled)

    // if possible, it would just have to authenticate itself once at startup or every 3 days or something
    // then it can just send requests to spx without a key
    // but that means writing to some buffer without hardware support for it. The hardware only supports ASID protections
    // up to 2^16 or was it 2^8

    // that means you can only have position independent code. No raw addresses or anything. Just stuff in .data who's vaddresses will be generated by the compiler or kernel or startup service and referencing them will be the same idea
    // the addresses must have certain ASID. Maybe a startup program can look through the binary and replace the j 0x... to something else
    // wait no, position independent just means the addresses in the binary are offsets in the binary

    match number {
        Register{resource} => {
            
        }
        RefreshKey{id} => {
            // find the executable id from the in memory key:val database

        }
    }
}

ServiceNumber: u64

const MAX_PENDING_SERVICES = 512

Service: {
    id: ServiceNumber
    buffer: *mut u8? = ()
    buffer_size_bytes: u64
    pid: Pid
}

// circular buffer (defined in core::types)
mut pending_services: CircularBuffer([Service; MAX_PENDING_SERVICES])

@interrupt_handler(HardwareWriteComplete)
handle_hardware_completion: (service_number: ServiceNumber, result_data: *mut u8) {
    mut res = pending_services.find(service_number).expect("Couldn't find service number...")
    // zero copy
    res.buffer = result_data
    // increase priority for pid in the global-local scheduler
    scheduler.find(pid).bump_priority()
}

InterruptType: enum {
    Syscall
    HardwareWriteComplete
}

use arcboot::InterruptCount

# A collection of platform independent interrupt handlers that can be written to the IVT
export default InterruptHandlers: [Interrupt; InterruptCount]
